
import
    os,
    re,
    bitops,
    strutils,
    strformat,
    parseopt


proc cvt_file(filename: string, out_h: var string, out_c_g: var string, out_c_f: var string)
proc color_code_256to16(byte: string): uint8

var opt_verbose = false


proc main() =
    var
        out_c: string
        out_h: string
        pgm_dir: string
        out_c_buf: string
        out_c_buf_g: string
        out_c_buf_s: string # inside init function
        out_h_buf: string
        out_h_buf_s: string # inside struct declaration

    for kind, key, val in getopt():
        case kind
            of cmdShortOption, cmdLongOption, cmdArgument:
                case key
                    of "h": out_h = val
                    of "c": out_c = val
                    of "p": pgm_dir = val
                    of "v": opt_verbose = true
            of cmdEnd: assert(false)

    if out_h.len == 0 or out_c.len == 0:
        echo "Usage: pgm2c -h header.h -c source.c -p path/to/pgm_files"
        quit QuitFailure

    for path in walkFiles(&"{pgm_dir}/*.pgm"):
        path.cvt_file(out_h_buf_s, out_c_buf_g, out_c_buf_s)

#----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----
    out_h_buf = &"""/* C header auto-generated by pgm2c, do not edit! */

#ifndef _BITMAPS_H_
#define _BITMAPS_H_

#include "omgui.h"

typedef struct gBitmaps {{
{out_h_buf_s}
}} AssetBitmapsT;

extern AssetBitmapsT AssetBitmaps;

void Bitmaps_Init(void);

#endif /* _BITMAPS_H_ */
"""
#----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----
    out_c_buf = &"""/* C source auto-generated by pgm2c, do not edit! */

#include "omgui.h"
#include "bitmaps.h"

{out_c_buf_g}

AssetBitmapsT AssetBitmaps;


void Bitmaps_Init(void)
{{
""" & out_c_buf_s & "\n}"
#----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----

    out_h.writeFile(out_h_buf)
    out_c.writeFile(out_c_buf)


proc cvt_file(filename: string, out_h: var string, out_c_g: var string, out_c_f: var string) =
    let name = splitFile(filename)[1]

    var
        fd_in = filename.open()
        line: string

        im_width: int
        im_height: int
        im_colors: int

        is_oddpixels: bool
        color_mark: bool
        data_sem: bool
        bytes_in_row_cnt: int = 0
        nbytes = 0
        is_byte1 = true
        byte1, byte2: string

    while fd_in.readLine(line):
        if line[0] == '#' or line[0] == 'P': # header
            continue

        elif line =~ re"^(\d+)\s+(\d+)$": # width height
            (im_width, im_height) = (matches[0].parseInt, matches[1].parseInt)

            is_oddpixels = if (im_width * im_height).bitand(1) == 1: true else: false
            # Fix buffer size for odd-pixels bitmaps
            let idx = int(im_width * im_height / 2) + (if is_oddpixels: 1 else: 0)

            out_c_g &= &"static const uint8_t bitmap_{name}_data[{idx}] = " & "{\n"
            color_mark = true

        elif color_mark: # colors
            im_colors = line.parseInt
            color_mark = false

        elif is_byte1:
            byte1 = line
            is_byte1 = false

            # Don't lose the last pixel of odd-pixels bitmap (i.e 27x33)
            if is_oddpixels and nbytes == int(im_width * im_height / 2):
              out_c_g &= "," & &"0x{color_code_256to16 byte1:x}0"
              nbytes.inc

            continue
        else: # byte2
            byte2 = line
            let color8bit = &"0x{color_code_256to16 byte1:x}{color_code_256to16 byte2:x}"
            var byte_sep = "," & color8bit

            if bytes_in_row_cnt == im_width.div(2):
                byte_sep = ",\n" & color8bit
                bytes_in_row_cnt = 0

            out_c_g &= (if data_sem: byte_sep else: color8bit)

            bytes_in_row_cnt.inc
            nbytes.inc

            data_sem = true
            is_byte1 = true

    fd_in.close()

    if opt_verbose:
        echo &"{filename.extractFilename()}: {nbytes} color bytes created"

    out_h &= &"    omBitmapT {name.capitalizeAscii};\n"

    out_c_g &= "\n};\n\n"
    out_c_f &= &"""
    AssetBitmaps.{name.capitalizeAscii} = ((omBitmapT) {{
        .Width = {im_width},
        .Height = {im_height},
        .ColorsNumOf = 16,
        .RawData = bitmap_{name}_data
    }});
"""


# Convert PGM's 8-bit 256 color code to 4-bit 16 colors (2 pixels/byte)
proc color_code_256to16(byte: string): uint8 =
    result = case byte
        of "0": 0 # "0x00"
        of "15": 1 # "0x11"
        of "30": 2 # "0x22"
        of "45": 3 # "0x33"
        of "60": 4 # "0x44"
        of "75": 5 # "0x55"
        of "90": 6 # "0x66"
        of "105": 7 # "0x77"
        of "120": 8 # "0x88"
        of "135": 9 # "0x99"
        of "150": 10 # "0xAA"
        of "165": 11 # "0xBB"
        of "180": 12 # "0xCC"
        of "195": 13 # "0xDD"
        of "210": 14 # "0xEE"
        of "225": 15 # "0xFF"
        else:
            echo &"Invalid color code: {byte}"
            quit QuitFailure


main()
