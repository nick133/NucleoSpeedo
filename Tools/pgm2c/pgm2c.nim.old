
import
  os,
  re,
  bitops,
  strutils,
  strformat,
  parseopt


proc cvt_file(filename: string, out_h: var string, out_c_global: var string, out_c_infunc: var string)
proc color_code_256to16(byte: string): uint8


proc main() =
  var
    out_c: string
    out_h: string
    pgm_dir: string
    out_c_buf: string
    out_c_buf_f: string # inside init func
    out_c_buf_g: string # globals
    out_h_buf: string

  for kind, key, val in getopt():
    case kind
      of cmdShortOption, cmdLongOption, cmdArgument:
        case key
          of "h": out_h = val
          of "c": out_c = val
          of "p": pgm_dir = val
      of cmdEnd: assert(false)

  if out_h.len == 0 or out_c.len == 0:
    echo "Usage: pgm2c -h header.h -c source.c -p path/to/pgm_files"
    quit QuitFailure

#----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----
  out_h_buf = """/* C header auto-generated by pgm2c, do not edit! */

#ifndef _BITMAPS_H_
#define _BITMAPS_H_

#include "omgui.h"

void Bitmaps_Init(void);

"""
#----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----

  for path in walkFiles(&"{pgm_dir}/*.pgm"):
    path.cvt_file(out_h_buf, out_c_buf_g, out_c_buf_f)

#----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----
  out_c_buf = """/* C source auto-generated by pgm2c, do not edit! */

#include "omgui.h"

""" & out_c_buf_g & """

void Bitmaps_Init(void)
{
""" & out_c_buf_f & "}\n"
#----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----8<----

  out_h_buf &= "\n#endif /* _BITMAPS_H_ */\n"

  out_h.writeFile(out_h_buf)
  out_c.writeFile(out_c_buf)


proc cvt_file(filename: string, out_h: var string, out_c_global: var string, out_c_infunc: var string) =
  let name = splitFile(filename)[1]

  var
    fd_in = filename.open()
    line: string

    im_width: int
    im_height: int
    im_colors: int

    is_oddpixels: bool
    color_mark: bool
    data_sem: bool
    bytes_in_row_cnt: int = 0
    nbytes = 0
    is_byte1 = true
    byte1, byte2: string

  out_c_global &= &"omBitmapT omBitmap_{name};\n\n"

  while fd_in.readLine(line):
    if line[0] == '#' or line[0] == 'P': # header
      continue

    elif line =~ re"^(\d+)\s+(\d+)$": # width height
      (im_width, im_height) = (matches[0].parseInt, matches[1].parseInt)

      is_oddpixels = if (im_width * im_height).bitand(1) == 1: true else: false
      # Fix buffer size for odd-pixels bitmaps
      let idx = int(im_width * im_height / 2) + (if is_oddpixels: 1 else: 0)

      out_c_global &= &"static const uint8_t bitmap_{name}_data[{idx}] = " & "{\n"
      color_mark = true

    elif color_mark: # colors
      im_colors = line.parseInt
      color_mark = false

    elif is_byte1:
        byte1 = line
        is_byte1 = false

        # Don't lose the last pixel of odd-pixels bitmap (i.e 27x33)
        if is_oddpixels and nbytes == int(im_width * im_height / 2):
          out_c_global &= "," & &"0x{color_code_256to16 byte1:x}0"
          nbytes.inc

        continue
    else: # byte2
      byte2 = line
      let color8bit = &"0x{color_code_256to16 byte1:x}{color_code_256to16 byte2:x}"
      var byte_sep = "," & color8bit

      if bytes_in_row_cnt == im_width.div(2):
        byte_sep = ",\n" & color8bit
        bytes_in_row_cnt = 0

      out_c_global &= (if data_sem: byte_sep else: color8bit)

      bytes_in_row_cnt.inc
      nbytes.inc

      data_sem = true
      is_byte1 = true

  fd_in.close()

  echo &"{filename.extractFilename()}: {nbytes} color bytes created"

  out_c_global &= "\n};\n\n"

  out_c_infunc &= &"""
  omBitmap_{name}.Width       = {im_width};
  omBitmap_{name}.Height      = {im_height};
  omBitmap_{name}.ColorsNumOf = 16;
  omBitmap_{name}.IsAlpha     = False;
  omBitmap_{name}.AlphaColor  = 0x00;
  omBitmap_{name}.RawData     = &bitmap_{name}_data[0];

"""

  out_h &= &"extern omBitmapT omBitmap_{name};\n"


# Convert PGM's 8-bit 256 color code to 4-bit 16 colors (2 pixels/byte)
proc color_code_256to16(byte: string): uint8 =
  result = case byte
    of "0": 0 # "0x00"
    of "15": 1 # "0x11"
    of "30": 2 # "0x22"
    of "45": 3 # "0x33"
    of "60": 4 # "0x44"
    of "75": 5 # "0x55"
    of "90": 6 # "0x66"
    of "105": 7 # "0x77"
    of "120": 8 # "0x88"
    of "135": 9 # "0x99"
    of "150": 10 # "0xAA"
    of "165": 11 # "0xBB"
    of "180": 12 # "0xCC"
    of "195": 13 # "0xDD"
    of "210": 14 # "0xEE"
    of "225": 15 # "0xFF"
    else:
      echo &"Invalid color code: {byte}"
      quit QuitFailure


main()
